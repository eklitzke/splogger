History
---------------------
The name for the eve system is based off of the original logging system used at
Yelp. That system had the same format for eve logs (although the format of the
GUID was different).

Architecture
-----------------
Eve works in conjunction with the splogger logging system. Splogger is highly
performant and provides guarantees about fault tolerancy. Eve refers both to
the log format and the API provided here. Nothing about eve is specific to
splogger -- in fact, the original eve system was built in the context of a
small non-distributed Twisted server.

Motivation
----------------------
The motivation for eve logs is to have a simple logging system that is easy to
use both from the perspective of a client emitting eve log entries, and as a
program parsing eve logs. It is expected that eve will be run in a networked
context (i.e. multiple clients are logging to a single server that aggregates
the logs), although that isn't inherently necessary to the use of eve.

The benefits of eve over other systems of logging/tracking large amounts of
date are:
 * networked
 * fault-tolerant/redundant when used with splogger
 * flexible log format (eve enforces almost no structure on logs)
 * easy to performance-tune (i.e. via sploggerd/spread)
 * easy to extend (all of the code is written in Python)

Eve is especially nice compared to using a database to log data. Since log
files can get very big, it's nice to keep them out of the database because the
log aggregator (sploggerd) can be run on another host. Additionally, many
database systems exhibit scalability issues in write-heavy environments,
whereas eve will not (assuming your storage devices are fast enough, of
course). Eve logs are easy to backup and manage compared to huge database
tables. Archival logs can be compressed easily. Additionally, eve logs can be
processed via the standard Unix toolkit of grep, awk, sed, etc.

How To Use Eve
--------------------
The customary way to use eve is to log reprs of simple python objects (almost
always dictionaries). You could use another format like JSON, and for more
complex objects you could use something like pickle, but by using repr it's
possible to take advantage of the standard eve log processing libraries. Of
course, there's not structure enforced whatsoever.

From the perspective of a logging client, there is a notion of a log system
that you are logging to. For example, you might log search data to a "search"
log, or click through data for servlet foo to the "click-foo" log. The way that
this actually happens is that the data ends up being logged to a separate file
for each kind of log. The details of how this work are determined by the
logging backend. In the eve/sploggerd combination the eve client class will
translate your log name into a code understood by splogger, and splogger has a
map of codes-to-names and will log the entries for a code into a file whose
name is like name.splog.

Code that logs using eve might look like this:

--------- BEGIN CODE BLOCK -----------
import eve.client

# the group is the name of the Spread group that the sploggerd is listening to
eve_client = eve.client.Client(port=4803, group="foo")
eve_client.send('test', repr({'bar': 1, baz: {'omg': 'wtf'}}))
---------- END CODE BLOCK -----------

In this example we instantiated an eve client that's going to log via splogger
using the spread instance listening on port 4803. We're logging to the
sploggerd instance that is receiving messages for the "foo" group (i.e. the
Spread group). The log system that the message was sent to is called "test"
(and will end up in a log named something like "test.splog").

The main loop of an eve processor might look something like this:

for line in open('foo.log'):
	guid, time, host, entry = line.split(' ', 3)
	entry = eval(entry)
	# do stuff here...

Log Rotation
----------------------
There are a couple of things you can do with respect to log rotation. It is
recommended that you rotate logs every day, so that each log contains entries
for a logical day.
